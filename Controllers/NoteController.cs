using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.AI;
using HW4NoteKeeper.Settings;
using HW4NoteKeeper.Data;
using HW4NoteKeeper.DataTransferObjects;
using NJsonSchema;
using Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;
using Azure.Storage.Blobs;
using HW4NoteKeeper.Services;

namespace HW4NoteKeeper.Controllers
{
    /// <summary>
    /// API Controller for managing notes, including creation, updating, retrieval, and deletion.
    /// </summary>
    [ApiController]
    [Route("[controller]")]
    public class NoteController : ControllerBase
    {
        private readonly ILogger<NoteController> _logger;
        private readonly IChatClient _chatClient;
        private readonly AISettings _aISettings;
        private readonly ApplicationDbContext _context;
        private readonly int _maxNotes;
        private readonly ITagGeneratorService _tagGeneratorService;
        private readonly IConfiguration _configuration;

        /// <summary>
        /// Initializes a new instance of the <see cref="NoteController"/> class.
        /// </summary>
        /// <param name="chatClient">The chat client used for AI-based tag generation.</param>
        /// <param name="aISettings">The AI settings configuration.</param>
        /// <param name="logger">The logger instance for logging operations.</param>
        /// <param name="context">The application's database context.</param>
        /// <param name="configuration">The configuration instance used to retrieve application settings.</param>
        /// <param name="tagGeneratorService">Service for generating tags using AI.</param>
        public NoteController(
            IChatClient chatClient,
            AISettings aISettings,
            ILogger<NoteController> logger,
            ApplicationDbContext context,
            IConfiguration configuration,
            ITagGeneratorService tagGeneratorService)
        {
            _logger = logger;
            _chatClient = chatClient;
            _aISettings = aISettings;
            _context = context;
            _configuration = configuration;
            _maxNotes = configuration.GetValue<int>("NoteSettings:MaxNotes", 10);
            _tagGeneratorService = tagGeneratorService;
        }

        /// <summary>
        /// Represents the expected JSON structure for the tags generated by the AI.
        /// </summary>
        public class TagsResponse
        {
            /// <summary>
            /// Gets or sets the list of generated one-word tags.
            /// </summary>
            public List<string> Phrases { get; set; } = new List<string>();
        }

        /// <summary>
        /// Creates a new note, generates AI-based tags, and stores it in the database.
        /// </summary>
        /// <param name="request">The note details including summary and content.</param>
        /// <returns>The created note.</returns>
        /// <response code="201">Successfully created the note.</response>
        /// <response code="400">Invalid summary or details input.</response>
        /// <response code="403">Note limit reached (MaxNotes exceeded).</response>
        /// <response code="500">AI Tag Generation failed.</response>
        [HttpPost("/notes")]
        [ProducesResponseType(typeof(CreateNoteRequest), 201)]
        [ProducesResponseType(400)]
        [ProducesResponseType(403)]
        [ProducesResponseType(500)]
        public async Task<IActionResult> CreateNote([FromBody, Required] CreateNoteRequest request)
        {
            int noteCount = await _context.Notes.CountAsync();
            if (noteCount >= _maxNotes)
            {
                return Problem(title: "Note limit reached",
                               detail: $"MaxNotes: [{_maxNotes}]",
                               statusCode: 403);
            }

            var generatedTags = await _tagGeneratorService.GenerateTagsAsync(request.Details);
            if (generatedTags.Count == 0)
            {
                return Problem(title: "AI Tag Generation Failed",
                               detail: "No tags were generated for this note.",
                               statusCode: 500);
            }

            var note = new Note
            {
                Summary = request.Summary,
                Details = request.Details,
                CreatedDateUtc = DateTimeOffset.UtcNow,
                ModifiedDateUtc = null,
                Tags = generatedTags.Select(tagName => new Tag
                {
                    Id = Guid.NewGuid(),
                    Name = tagName
                }).ToList()
            };

            _context.Notes.Add(note);
            await _context.SaveChangesAsync();
            _logger.LogInformation($"Note created with ID: {note.Id}");

            return CreatedAtAction(nameof(GetNoteById), new { id = note.Id }, note);
        }

        /// <summary>
        /// Updates the summary and/or details of an existing note, regenerating tags if details change.
        /// </summary>
        /// <param name="id">The note ID.</param>
        /// <param name="request">The update payload containing optional summary and details fields.</param>
        /// <returns>No content if the update succeeds; an error response otherwise.</returns>
        [HttpPatch("/notes/{id}")]
        [ProducesResponseType(204)]
        [ProducesResponseType(400)]
        [ProducesResponseType(404)]
        [ProducesResponseType(409)]
        public async Task<IActionResult> UpdateNote(Guid id, [FromBody] UpdateNoteRequest request)
        {
            if (id == Guid.Empty)
            {
                return BadRequest("Invalid note ID.");
            }

            var note = await _context.Notes.Include(n => n.Tags).FirstOrDefaultAsync(n => n.Id == id);
            if (note == null)
            {
                return NotFound();
            }

            bool summaryProvided = !string.IsNullOrWhiteSpace(request.Summary);
            bool detailsProvided = !string.IsNullOrWhiteSpace(request.Details);
            bool scalarUpdated = false;

            if (summaryProvided)
            {
                note.Summary = request.Summary!;
                scalarUpdated = true;
            }

            if (detailsProvided)
            {
                note.Details = request.Details!;
                scalarUpdated = true;
            }

            if (scalarUpdated)
            {
                note.ModifiedDateUtc = DateTimeOffset.UtcNow;
                try
                {
                    await _context.SaveChangesAsync();
                }
                catch (DbUpdateConcurrencyException ex)
                {
                    _logger.LogError(ex, "Concurrency error updating note scalars for id {NoteId}", id);
                    return Conflict("The note was modified concurrently. Please refresh and try again.");
                }
            }

            if (detailsProvided)
            {
                var generatedTags = await _tagGeneratorService.GenerateTagsAsync(request.Details!);
                if (generatedTags.Count == 0)
                {
                    return Problem(title: "AI Tag Generation Failed",
                                  detail: "No tags were generated for this note.",
                                  statusCode: 500);
                }

                _context.Tags.RemoveRange(note.Tags);
                try
                {
                    await _context.SaveChangesAsync();
                }
                catch (DbUpdateConcurrencyException ex)
                {
                    _logger.LogError(ex, "Concurrency error deleting tags for note id {NoteId}", id);
                    return Conflict("The tags were modified concurrently. Please refresh and try again.");
                }

                note = await _context.Notes.Include(n => n.Tags).FirstOrDefaultAsync(n => n.Id == id);
                if (note == null)
                {
                    return NotFound();
                }

                var newTags = generatedTags.Select(tagName => new Tag
                {
                    Id = Guid.NewGuid(),
                    Name = tagName,
                    NoteId = note.Id
                }).ToList();

                _context.Tags.AddRange(newTags);
                note.Tags = newTags;
                int tagCount = newTags.Count;

                try
                {
                    await _context.SaveChangesAsync();
                }
                catch (DbUpdateConcurrencyException ex)
                {
                    _logger.LogError(ex, "Concurrency error inserting new tags for note id {NoteId}", id);
                    return Conflict("The tags were modified concurrently. Please refresh your data and try again.");
                }
            }

            return NoContent();
        }

        /// <summary>
        /// Deletes a note and its associated tags.
        /// </summary>
        /// <param name="id">The note ID.</param>
        /// <returns>No content if deletion is successful.</returns>
        /// <response code="204">Successfully deleted the note.</response>
        /// <response code="404">Note not found.</response>
        [HttpDelete("/notes/{id}")]
        [ProducesResponseType(204)]
        [ProducesResponseType(404)]
        public async Task<IActionResult> DeleteNote(Guid id)
        {
            if (id == Guid.Empty)
            {
                return BadRequest("Invalid note ID.");
            }

            var note = await _context.Notes.Include(n => n.Tags).FirstOrDefaultAsync(n => n.Id == id);
            if (note == null)
            {
                return NotFound();
            }

            using var transaction = await _context.Database.BeginTransactionAsync();
            try
            {
                _context.Tags.RemoveRange(note.Tags);
                await _context.SaveChangesAsync();

                _context.Notes.Remove(note);
                await _context.SaveChangesAsync();

                await transaction.CommitAsync();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error deleting note or its tags for noteId {NoteId}", id);
                return StatusCode(500, "Error deleting note or its tags.");
            }

            // Delete attachments from Azure Blob Storage.
            string storageConnectionString = _configuration.GetConnectionString("DefaultStorageConnection")!;
            if (!string.IsNullOrEmpty(storageConnectionString))
            {
                string containerName = note.Id.ToString().ToLowerInvariant();
                BlobContainerClient containerClient = new BlobContainerClient(storageConnectionString, containerName);
                try
                {
                    await containerClient.DeleteIfExistsAsync();
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error deleting blob container {ContainerName}", containerName);
                }
            }
            else
            {
                _logger.LogWarning("Storage connection string is not configured; skipping attachment deletion.");
            }

            return NoContent();
        }

        /// <summary>
        /// Retrieves a note by its ID.
        /// </summary>
        /// <param name="id">The note ID.</param>
        /// <returns>The requested note.</returns>
        /// <response code="200">Note found.</response>
        /// <response code="404">Note not found.</response>
        [HttpGet("/notes/{id}")]
        [ProducesResponseType(typeof(Note), 200)]
        [ProducesResponseType(404)]
        public async Task<IActionResult> GetNoteById(Guid id)
        {
            var note = await _context.Notes.Include(n => n.Tags).FirstOrDefaultAsync(n => n.Id == id);
            if (note == null)
                return NotFound();

            return Ok(note);
        }

        /// <summary>
        /// Retrieves all notes, optionally filtered by tag name.
        /// </summary>
        /// <param name="tagName">Optional filter by tag name.</param>
        /// <returns>A list of notes with simplified properties.</returns>
        /// <response code="200">Notes retrieved successfully.</response>
        [HttpGet("/notes")]
        [ProducesResponseType(typeof(IEnumerable<object>), 200)]
        public async Task<IActionResult> GetAllNotes([FromQuery] string? tagName = null)
        {
            IQueryable<Note> query = _context.Notes.Include(n => n.Tags);

            if (!string.IsNullOrWhiteSpace(tagName))
            {
                query = query.Where(n => n.Tags.Any(t => t.Name.ToLower() == tagName.ToLower()));
            }

            var result = await query.Select(n => new
            {
                noteId = n.Id,
                summary = n.Summary,
                details = n.Details,
                createdDateUtc = n.CreatedDateUtc,
                modifiedDateUtc = n.ModifiedDateUtc,
                tags = n.TagNames
            }).ToListAsync();

            return Ok(result);
        }

        /// <summary>
        /// Retrieves a list of unique tags.
        /// </summary>
        /// <returns>A list of unique tag objects with a 'name' property.</returns>
        /// <response code="200">Tags retrieved successfully.</response>
        [HttpGet("/tags")]
        [ProducesResponseType(typeof(IEnumerable<object>), 200)]
        public async Task<IActionResult> GetAllTags()
        {
            var distinctTagNames = await _context.Tags
                .Select(t => t.Name)
                .Distinct()
                .ToListAsync();

            var result = distinctTagNames.Select(tagName => new { name = tagName });
            return Ok(result);
        }
    }
}
